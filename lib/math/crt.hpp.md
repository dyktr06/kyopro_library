---
data:
  _extendedDependsOn: []
  _extendedRequiredBy:
  - icon: ':heavy_check_mark:'
    path: lib/convolution/ntt.hpp
    title: Number Theoretic Transform
  - icon: ':heavy_check_mark:'
    path: lib/enumerative_combinatorics/partition_function.hpp
    title: "Partition Function (\u5206\u5272\u6570)"
  - icon: ':heavy_check_mark:'
    path: lib/enumerative_combinatorics/stirling_number_2nd.hpp
    title: "Stirling Number of the Second Kind (\u7B2C 2 \u7A2E\u30B9\u30BF\u30FC\u30EA\
      \u30F3\u30B0\u6570)"
  - icon: ':heavy_check_mark:'
    path: lib/enumerative_combinatorics/subset_sum.hpp
    title: Subset Sum
  - icon: ':heavy_check_mark:'
    path: lib/math/bell_number.hpp
    title: "Bell Number (\u30D9\u30EB\u6570)"
  - icon: ':heavy_check_mark:'
    path: lib/math/bernoulli_number.hpp
    title: "Bernoulli Number (\u30D9\u30EB\u30CC\u30FC\u30A4\u6570)"
  - icon: ':heavy_check_mark:'
    path: lib/polynomial/bostan_mori.hpp
    title: Bostan-Mori
  - icon: ':heavy_check_mark:'
    path: lib/polynomial/formal_power_series.hpp
    title: "Formal Power Series (\u5F62\u5F0F\u7684\u51AA\u7D1A\u6570)"
  - icon: ':heavy_check_mark:'
    path: lib/polynomial/multipoint_evaluation.hpp
    title: "Multipoint Evaluation (\u591A\u70B9\u8A55\u4FA1)"
  - icon: ':heavy_check_mark:'
    path: lib/polynomial/polynomial_interpolation.hpp
    title: "Polynomial Interpolation (\u591A\u9805\u5F0F\u88DC\u9593)"
  - icon: ':heavy_check_mark:'
    path: lib/polynomial/product_of_polynomial_sequence.hpp
    title: "Product of Polynomial Sequence (\u591A\u9805\u5F0F\u5217\u306E\u7DCF\u7A4D\
      )"
  - icon: ':heavy_check_mark:'
    path: lib/polynomial/taylor_shift.hpp
    title: Taylor Shift
  - icon: ':heavy_check_mark:'
    path: lib/string/wildcard_pattern_matching.hpp
    title: Wildcard Pattern Matching
  _extendedVerifiedWith:
  - icon: ':heavy_check_mark:'
    path: test/library_checker/convolution/convolution.test.cpp
    title: test/library_checker/convolution/convolution.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/library_checker/convolution/convolution_mod_1000000007.test.cpp
    title: test/library_checker/convolution/convolution_mod_1000000007.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/library_checker/enumerative_combinatorics/partition_function.test.cpp
    title: test/library_checker/enumerative_combinatorics/partition_function.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/library_checker/enumerative_combinatorics/sharp_p_subset_sum.test.cpp
    title: test/library_checker/enumerative_combinatorics/sharp_p_subset_sum.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/library_checker/enumerative_combinatorics/stirling_number_of_the_second_kind.test.cpp
    title: test/library_checker/enumerative_combinatorics/stirling_number_of_the_second_kind.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/library_checker/enumerative_combinatorics/stirling_number_of_the_second_kind_fixed_k.test.cpp
    title: test/library_checker/enumerative_combinatorics/stirling_number_of_the_second_kind_fixed_k.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/library_checker/number_theory/bell_number.test.cpp
    title: test/library_checker/number_theory/bell_number.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/library_checker/number_theory/bernoulli_number.test.cpp
    title: test/library_checker/number_theory/bernoulli_number.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/library_checker/other/kth_term_of_linearly_recurrent_sequence.test.cpp
    title: test/library_checker/other/kth_term_of_linearly_recurrent_sequence.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/library_checker/polynomial/division_of_polynomials.test.cpp
    title: test/library_checker/polynomial/division_of_polynomials.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/library_checker/polynomial/exp_of_formal_power_series.test.cpp
    title: test/library_checker/polynomial/exp_of_formal_power_series.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/library_checker/polynomial/inv_of_formal_power_series.test.cpp
    title: test/library_checker/polynomial/inv_of_formal_power_series.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/library_checker/polynomial/log_of_formal_power_series.test.cpp
    title: test/library_checker/polynomial/log_of_formal_power_series.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/library_checker/polynomial/multipoint_evaluation.test.cpp
    title: test/library_checker/polynomial/multipoint_evaluation.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/library_checker/polynomial/polynomial_interpolation.test.cpp
    title: test/library_checker/polynomial/polynomial_interpolation.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/library_checker/polynomial/polynomial_taylor_shift.test.cpp
    title: test/library_checker/polynomial/polynomial_taylor_shift.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/library_checker/polynomial/pow_of_formal_power_series.test.cpp
    title: test/library_checker/polynomial/pow_of_formal_power_series.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/library_checker/polynomial/product_of_polynomial_sequence.test.cpp
    title: test/library_checker/polynomial/product_of_polynomial_sequence.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/library_checker/polynomial/sqrt_of_formal_power_series.test.cpp
    title: test/library_checker/polynomial/sqrt_of_formal_power_series.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/library_checker/string/wildcard_pattern_matching.test.cpp
    title: test/library_checker/string/wildcard_pattern_matching.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/yukicoder/yuki_186.test.cpp
    title: test/yukicoder/yuki_186.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/yukicoder/yuki_187.test.cpp
    title: test/yukicoder/yuki_187.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/yukicoder/yuki_2119.test.cpp
    title: test/yukicoder/yuki_2119.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/yukicoder/yuki_3022.test.cpp
    title: test/yukicoder/yuki_3022.test.cpp
  _isVerificationFailed: false
  _pathExtension: hpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    _deprecated_at_docs: docs/math/crt.md
    document_title: "Chinese Remainder Theorem (\u4E2D\u56FD\u5270\u4F59\u5B9A\u7406\
      )"
    links: []
  bundledCode: "#line 2 \"lib/math/crt.hpp\"\n\n/**\n * @brief Chinese Remainder Theorem\
    \ (\u4E2D\u56FD\u5270\u4F59\u5B9A\u7406)\n * @docs docs/math/crt.md\n */\n\n#include\
    \ <numeric>\n#include <vector>\n\nnamespace CRT{\n    inline long long mod(long\
    \ long a, long long m){\n        return (a % m + m) % m;\n    }\n\n    long long\
    \ extGCD(long long a, long long b, long long &x, long long &y){\n        if(b\
    \ == 0){\n            x = 1;\n            y = 0;\n            return a;\n    \
    \    }\n        long long d = extGCD(b, a % b, y, x);\n        y -= a / b * x;\n\
    \        return d;\n    }\n\n    std::pair<long long, long long> chineseRem(const\
    \ std::vector<long long> &b, const std::vector<long long> &m) {\n        long\
    \ long r = 0, M = 1;\n        for(int i = 0; i < (int) b.size(); i++){\n     \
    \       long long p, q;\n            long long d = extGCD(M, m[i], p, q);\n  \
    \          if((b[i] - r) % d != 0) return {0, -1};\n            long long tmp\
    \ = (b[i] - r) / d * p % (m[i] / d);\n            r += M * tmp;\n            M\
    \ *= m[i] / d;\n        }\n        r %= M;\n        if(r < 0) r += M;\n      \
    \  return {r, M};\n    }\n\n    // not coprime\n    long long preGarner(std::vector<long\
    \ long> &b, std::vector<long long> &m, const long long MOD){\n        long long\
    \ res = 1;\n        int n = b.size();\n        for(int i = 0; i < n; i++){\n \
    \           for(int j = 0; j < i; j++){\n                long long g = std::gcd(m[i],\
    \ m[j]);\n                if((b[i] - b[j]) % g != 0) return -1;\n            \
    \    m[i] /= g, m[j] /= g;\n                // gcd \u306E\u5206\u3060\u3051\u88AB\
    \u3063\u3066\u308B\u306E\u3067\u632F\u308A\u5206\u3051\u308B\n               \
    \ long long gi = std::gcd(m[i], g), gj = g / gi;\n                do{\n      \
    \              g = std::gcd(gi, gj);\n                    gi *= g, gj /= g;\n\
    \                }while(g != 1);\n                m[i] *= gi, m[j] *= gj;\n  \
    \              b[i] %= m[i], b[j] %= m[j];\n            }\n        }\n       \
    \ for(auto x : m) (res *= x) %= MOD;\n        return res;\n    }\n\n    long long\
    \ garner(const std::vector<long long> &b, const std::vector<long long> &m, const\
    \ long long MOD){\n        std::vector<long long> tm = m;\n        tm.push_back(MOD);\n\
    \        auto inv = [&](long long a, long long m) -> long long {\n           \
    \ long long x, y;\n            extGCD(a, m, x, y);\n            return mod(x,\
    \ m);\n        };\n        int n = b.size();\n        std::vector<long long> coeffs(n\
    \ + 1, 1), constants(n + 1, 0);\n        for(int i = 0; i < n; i++){\n       \
    \     // solve \"coeffs[i] * t[i] + constants[i] = b[i] (mod. m[i])\n        \
    \    long long t = mod((b[i] - constants[i]) * inv(coeffs[i], tm[i]), tm[i]);\n\
    \            for(int j = i + 1; j < n + 1; j++){\n                (constants[j]\
    \ += t * coeffs[j]) %= tm[j];\n                (coeffs[j] *= tm[i]) %= tm[j];\n\
    \            }\n        }\n        return constants[n];\n    }\n\n    // ax +\
    \ b \u2261 0 (mod m)\n    long long modEquation(long long a, long long b, long\
    \ long m, bool is_positive = false){\n        a %= m; b %= m;\n        b = (m\
    \ - b) % m;\n        long long g = std::gcd(a, m);\n        if(b % g != 0) return\
    \ -1;\n        a /= g; b /= g; m /= g;\n        if(is_positive && b == 0){\n \
    \           return m;\n        }\n        long long x, y;\n        extGCD(a, m,\
    \ x, y);\n        return (b * x % m + m) % m;\n    }\n}\n"
  code: "#pragma once\n\n/**\n * @brief Chinese Remainder Theorem (\u4E2D\u56FD\u5270\
    \u4F59\u5B9A\u7406)\n * @docs docs/math/crt.md\n */\n\n#include <numeric>\n#include\
    \ <vector>\n\nnamespace CRT{\n    inline long long mod(long long a, long long\
    \ m){\n        return (a % m + m) % m;\n    }\n\n    long long extGCD(long long\
    \ a, long long b, long long &x, long long &y){\n        if(b == 0){\n        \
    \    x = 1;\n            y = 0;\n            return a;\n        }\n        long\
    \ long d = extGCD(b, a % b, y, x);\n        y -= a / b * x;\n        return d;\n\
    \    }\n\n    std::pair<long long, long long> chineseRem(const std::vector<long\
    \ long> &b, const std::vector<long long> &m) {\n        long long r = 0, M = 1;\n\
    \        for(int i = 0; i < (int) b.size(); i++){\n            long long p, q;\n\
    \            long long d = extGCD(M, m[i], p, q);\n            if((b[i] - r) %\
    \ d != 0) return {0, -1};\n            long long tmp = (b[i] - r) / d * p % (m[i]\
    \ / d);\n            r += M * tmp;\n            M *= m[i] / d;\n        }\n  \
    \      r %= M;\n        if(r < 0) r += M;\n        return {r, M};\n    }\n\n \
    \   // not coprime\n    long long preGarner(std::vector<long long> &b, std::vector<long\
    \ long> &m, const long long MOD){\n        long long res = 1;\n        int n =\
    \ b.size();\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j\
    \ < i; j++){\n                long long g = std::gcd(m[i], m[j]);\n          \
    \      if((b[i] - b[j]) % g != 0) return -1;\n                m[i] /= g, m[j]\
    \ /= g;\n                // gcd \u306E\u5206\u3060\u3051\u88AB\u3063\u3066\u308B\
    \u306E\u3067\u632F\u308A\u5206\u3051\u308B\n                long long gi = std::gcd(m[i],\
    \ g), gj = g / gi;\n                do{\n                    g = std::gcd(gi,\
    \ gj);\n                    gi *= g, gj /= g;\n                }while(g != 1);\n\
    \                m[i] *= gi, m[j] *= gj;\n                b[i] %= m[i], b[j] %=\
    \ m[j];\n            }\n        }\n        for(auto x : m) (res *= x) %= MOD;\n\
    \        return res;\n    }\n\n    long long garner(const std::vector<long long>\
    \ &b, const std::vector<long long> &m, const long long MOD){\n        std::vector<long\
    \ long> tm = m;\n        tm.push_back(MOD);\n        auto inv = [&](long long\
    \ a, long long m) -> long long {\n            long long x, y;\n            extGCD(a,\
    \ m, x, y);\n            return mod(x, m);\n        };\n        int n = b.size();\n\
    \        std::vector<long long> coeffs(n + 1, 1), constants(n + 1, 0);\n     \
    \   for(int i = 0; i < n; i++){\n            // solve \"coeffs[i] * t[i] + constants[i]\
    \ = b[i] (mod. m[i])\n            long long t = mod((b[i] - constants[i]) * inv(coeffs[i],\
    \ tm[i]), tm[i]);\n            for(int j = i + 1; j < n + 1; j++){\n         \
    \       (constants[j] += t * coeffs[j]) %= tm[j];\n                (coeffs[j]\
    \ *= tm[i]) %= tm[j];\n            }\n        }\n        return constants[n];\n\
    \    }\n\n    // ax + b \u2261 0 (mod m)\n    long long modEquation(long long\
    \ a, long long b, long long m, bool is_positive = false){\n        a %= m; b %=\
    \ m;\n        b = (m - b) % m;\n        long long g = std::gcd(a, m);\n      \
    \  if(b % g != 0) return -1;\n        a /= g; b /= g; m /= g;\n        if(is_positive\
    \ && b == 0){\n            return m;\n        }\n        long long x, y;\n   \
    \     extGCD(a, m, x, y);\n        return (b * x % m + m) % m;\n    }\n}\n"
  dependsOn: []
  isVerificationFile: false
  path: lib/math/crt.hpp
  requiredBy:
  - lib/string/wildcard_pattern_matching.hpp
  - lib/enumerative_combinatorics/partition_function.hpp
  - lib/enumerative_combinatorics/subset_sum.hpp
  - lib/enumerative_combinatorics/stirling_number_2nd.hpp
  - lib/math/bernoulli_number.hpp
  - lib/math/bell_number.hpp
  - lib/convolution/ntt.hpp
  - lib/polynomial/product_of_polynomial_sequence.hpp
  - lib/polynomial/formal_power_series.hpp
  - lib/polynomial/multipoint_evaluation.hpp
  - lib/polynomial/bostan_mori.hpp
  - lib/polynomial/taylor_shift.hpp
  - lib/polynomial/polynomial_interpolation.hpp
  timestamp: '2025-02-15 00:03:46+09:00'
  verificationStatus: LIBRARY_ALL_AC
  verifiedWith:
  - test/yukicoder/yuki_3022.test.cpp
  - test/yukicoder/yuki_187.test.cpp
  - test/yukicoder/yuki_2119.test.cpp
  - test/yukicoder/yuki_186.test.cpp
  - test/library_checker/string/wildcard_pattern_matching.test.cpp
  - test/library_checker/other/kth_term_of_linearly_recurrent_sequence.test.cpp
  - test/library_checker/enumerative_combinatorics/stirling_number_of_the_second_kind_fixed_k.test.cpp
  - test/library_checker/enumerative_combinatorics/sharp_p_subset_sum.test.cpp
  - test/library_checker/enumerative_combinatorics/stirling_number_of_the_second_kind.test.cpp
  - test/library_checker/enumerative_combinatorics/partition_function.test.cpp
  - test/library_checker/number_theory/bernoulli_number.test.cpp
  - test/library_checker/number_theory/bell_number.test.cpp
  - test/library_checker/convolution/convolution.test.cpp
  - test/library_checker/convolution/convolution_mod_1000000007.test.cpp
  - test/library_checker/polynomial/log_of_formal_power_series.test.cpp
  - test/library_checker/polynomial/polynomial_taylor_shift.test.cpp
  - test/library_checker/polynomial/polynomial_interpolation.test.cpp
  - test/library_checker/polynomial/sqrt_of_formal_power_series.test.cpp
  - test/library_checker/polynomial/exp_of_formal_power_series.test.cpp
  - test/library_checker/polynomial/multipoint_evaluation.test.cpp
  - test/library_checker/polynomial/product_of_polynomial_sequence.test.cpp
  - test/library_checker/polynomial/pow_of_formal_power_series.test.cpp
  - test/library_checker/polynomial/division_of_polynomials.test.cpp
  - test/library_checker/polynomial/inv_of_formal_power_series.test.cpp
documentation_of: lib/math/crt.hpp
layout: document
redirect_from:
- /library/lib/math/crt.hpp
- /library/lib/math/crt.hpp.html
title: "Chinese Remainder Theorem (\u4E2D\u56FD\u5270\u4F59\u5B9A\u7406)"
---
## Chinese Remainder Theorem (中国剰余定理)

#### 使い方

- `CRT::extGCD(a, b, x, y)`: $ax + by =$ gcd($a, b$) となる $x, y$ を求めます。
- `CRT::ChineseRem(b, m)`: 中国剰余定理の計算を行います。返り値を (r, m) とすると解は x ≡ r (mod. m)、解なしの場合は (0, -1) を返します。

注意: lcmのオーバーフローに注意する。

#### 計算量

- `CRT::extGCD(a, b, x, y)`: $\mathrm{O}(\log a)$
- `CRT::ChineseRem(b, m)`: $\mathrm{O}(N \log \mathrm{lcm}(m))$ (配列の長さを $N$ とする)